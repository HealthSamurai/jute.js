// Generated by CoffeeScript 1.10.0
(function() {
  var DIRECTIVES, HELPERS, evalDirective, evalFilter, evalIf, evalJs, evalLet, evalMap, evalNode, evalObject, evalString, evalSwitch, expr, firstKeyName, intersectArrays, isDirective, makeChildScope, nodeValue, transform;

  expr = require("./expression");

  HELPERS = {
    join: function(s, sep) {
      return s.join(sep);
    }
  };

  intersectArrays = function(a, b) {
    var aVal, bVal, i, j, len, len1, result;
    result = [];
    for (i = 0, len = a.length; i < len; i++) {
      aVal = a[i];
      for (j = 0, len1 = b.length; j < len1; j++) {
        bVal = b[j];
        if (aVal === bVal) {
          result.push(aVal);
        }
      }
    }
    return result;
  };

  makeChildScope = function(scope) {
    var childScope;
    childScope = {};
    childScope.__proto__ = scope;
    return childScope;
  };

  firstKeyName = function(object) {
    return Object.keys(object)[0];
  };

  evalLet = function(node, scope) {
    var addVarToScope, body, childScope, i, k, len, ref, ref1, v, varDecl, varName;
    childScope = makeChildScope(scope);
    addVarToScope = function(name, node) {
      return childScope[name] = evalNode(node, childScope);
    };
    if (Array.isArray(node.$let)) {
      ref = node.$let;
      for (i = 0, len = ref.length; i < len; i++) {
        varDecl = ref[i];
        varName = firstKeyName(varDecl);
        if (varName) {
          addVarToScope(varName, varDecl[varName]);
        }
      }
    } else {
      ref1 = node.$let;
      for (k in ref1) {
        v = ref1[k];
        addVarToScope(k, v);
      }
    }
    body = node.$body;
    if (typeof body === 'undefined') {
      throw "No $body attr in $let node: " + JSON.stringify(node);
    }
    return evalNode(body, childScope);
  };

  evalIf = function(node, scope) {
    var evalResult, v;
    evalResult = expr["eval"](node.$if, scope);
    if (evalResult) {
      v = nodeValue(node, '$then');
      return evalNode(v, scope);
    } else {
      return evalNode(node.$else || null, scope);
    }
  };

  evalSwitch = function(node, scope) {
    var evalResult, resultNode;
    evalResult = expr["eval"](node.$switch, scope);
    resultNode = node[evalResult];
    if (typeof resultNode === 'undefined') {
      resultNode = node['$default'];
    }
    if (typeof resultNode === 'undefined') {
      return null;
    } else {
      return evalNode(resultNode, scope);
    }
  };

  evalFilter = function(node, scope) {
    var applyFilter, f, filters, i, len, result, val;
    filters = node.$filter;
    val = evalNode(nodeValue(node, '$body'), scope);
    applyFilter = function(filterName, val) {
      var filterArgs, filterFn;
      if (filterName.indexOf('(') > 0) {
        filterArgs = filterName.match(/\(([^)]+)\)$/)[1].split(",").map(JSON.parse);
        filterName = filterName.substr(0, filterName.indexOf("("));
      } else {
        filterArgs = [];
      }
      filterFn = HELPERS[filterName];
      if (!filterFn) {
        throw "Unknown filter: '" + filterName + "'";
      }
      return filterFn.apply(scope, [val].concat(filterArgs));
    };
    if (Array.isArray(filters)) {
      result = val;
      for (i = 0, len = filters.length; i < len; i++) {
        f = filters[i];
        result = applyFilter(f, result);
      }
      return result;
    } else {
      return applyFilter(filters, val);
    }
  };

  evalJs = function(node, scope) {
    return eval(node.$js);
  };

  evalMap = function(node, scope) {
    var array, childScope, result, value, varName;
    array = expr["eval"](node.$map, scope);
    varName = node.$as;
    value = nodeValue(node, '$body');
    result = [];
    childScope = makeChildScope(scope);
    array.forEach(function(item) {
      childScope[varName] = item;
      return result.push(evalNode(value, childScope));
    });
    return result;
  };

  nodeValue = function(node, valueAttr) {
    var key, value, valueObject;
    valueObject = node[valueAttr || '$value'];
    if (typeof valueObject !== 'undefined') {
      return valueObject;
    } else {
      valueObject = {};
      for (key in node) {
        value = node[key];
        if (!key.match(/^\$/)) {
          valueObject[key] = value;
        }
      }
      return valueObject;
    }
  };

  DIRECTIVES = {
    $if: evalIf,
    $switch: evalSwitch,
    $let: evalLet,
    $filter: evalFilter,
    $map: evalMap,
    $js: evalJs
  };

  isDirective = function(node) {
    var key, value;
    for (key in node) {
      value = node[key];
      if (key.match(/^\$/)) {
        return true;
      }
    }
    return false;
  };

  evalDirective = function(node, scope) {
    var directiveFn, directiveName, keys, knownDirectives, nodeKeys;
    knownDirectives = Object.keys(DIRECTIVES);
    nodeKeys = Object.keys(node);
    keys = intersectArrays(nodeKeys, knownDirectives);
    if (keys.length === 0) {
      throw "Could not find known directive among " + (nodeKeys.join(', ')) + "; Known directives are: " + (knownDirectives.join(', '));
    } else if (keys.length > 1) {
      throw "Ambigous node with multiple directives found: " + (keys.join(', '));
    }
    directiveName = keys[0];
    directiveFn = DIRECTIVES[directiveName];
    return directiveFn(node, scope);
  };

  evalObject = function(node, scope) {
    var key, result, value;
    if (isDirective(node)) {
      return evalDirective(node, scope);
    } else {
      result = {};
      for (key in node) {
        value = node[key];
        result[key] = evalNode(value, scope);
      }
      return result;
    }
  };

  evalString = function(node, scope) {
    var expressionStartRegexp;
    expressionStartRegexp = /^\s*\$\s+/;
    if (node.match(expressionStartRegexp)) {
      return expr["eval"](node.replace(expressionStartRegexp, ''), scope);
    } else {
      return node;
    }
  };

  evalNode = function(node, scope) {
    var nodeType;
    if (typeof scope === 'undefined') {
      throw "evalNode() called with undefined scope. Node is: " + (JSON.stringify(node));
    }
    nodeType = typeof node;
    if (nodeType === 'object' && node !== null) {
      if (Array.isArray(node)) {
        return node.map(function(element) {
          return evalNode(element, scope);
        });
      } else {
        return evalObject(node, scope);
      }
    } else {
      if (nodeType === 'string') {
        return evalString(node, scope);
      } else if (nodeType === 'undefined') {
        return null;
      } else {
        return node;
      }
    }
  };

  transform = function(scope, template) {
    return evalNode(template, scope);
  };

  module.exports = {
    transform: transform
  };

}).call(this);
