// Generated by CoffeeScript 1.10.0
(function() {
  var DIRECTIVES, HELPERS, evalDirective, evalExpression, evalFilter, evalIf, evalJs, evalLet, evalMap, evalNode, evalObject, evalString, evalSwitch, firstKeyName, getIn, intersectArrays, isDirective, makeChildScope, nodeValue, parsePath, parser, transform;

  parser = require("./parser");

  HELPERS = {
    join: function(s, sep) {
      return s.join(sep);
    }
  };

  intersectArrays = function(a, b) {
    var aVal, bVal, i, j, len, len1, result;
    result = [];
    for (i = 0, len = a.length; i < len; i++) {
      aVal = a[i];
      for (j = 0, len1 = b.length; j < len1; j++) {
        bVal = b[j];
        if (aVal === bVal) {
          result.push(aVal);
        }
      }
    }
    return result;
  };

  makeChildScope = function(scope) {
    var childScope;
    childScope = {};
    childScope.__proto__ = scope;
    return childScope;
  };

  firstKeyName = function(object) {
    return Object.keys(object)[0];
  };

  evalLet = function(node, scope) {
    var addVarToScope, body, childScope, i, k, len, ref, ref1, v, varDecl, varName;
    childScope = makeChildScope(scope);
    addVarToScope = function(name, node) {
      return childScope[name] = evalNode(node, childScope);
    };
    if (Array.isArray(node.$let)) {
      ref = node.$let;
      for (i = 0, len = ref.length; i < len; i++) {
        varDecl = ref[i];
        varName = firstKeyName(varDecl);
        if (varName) {
          addVarToScope(varName, varDecl[varName]);
        }
      }
    } else {
      ref1 = node.$let;
      for (k in ref1) {
        v = ref1[k];
        addVarToScope(k, v);
      }
    }
    body = node.$body;
    if (typeof body === 'undefined') {
      throw "No $body attr in $let node: " + JSON.stringify(node);
    }
    return evalNode(body, childScope);
  };

  evalIf = function(node, scope) {
    var evalResult, v;
    evalResult = evalExpression(node.$if, scope);
    if (evalResult) {
      v = nodeValue(node, '$then');
      return evalNode(v, scope);
    } else {
      return evalNode(node.$else || null, scope);
    }
  };

  evalSwitch = function(node, scope) {
    var evalResult, resultNode;
    evalResult = evalExpression(node.$switch, scope);
    resultNode = node[evalResult];
    if (typeof resultNode === 'undefined') {
      resultNode = node['$default'];
    }
    if (typeof resultNode === 'undefined') {
      return null;
    } else {
      return evalNode(resultNode, scope);
    }
  };

  evalFilter = function(node, scope) {
    var applyFilter, f, filters, i, len, result, val;
    filters = node.$filter;
    val = evalNode(nodeValue(node, '$body'), scope);
    applyFilter = function(filterName, val) {
      var filterArgs, filterFn;
      if (filterName.indexOf('(') > 0) {
        filterArgs = filterName.match(/\(([^)]+)\)$/)[1].split(",").map(JSON.parse);
        filterName = filterName.substr(0, filterName.indexOf("("));
      } else {
        filterArgs = [];
      }
      filterFn = HELPERS[filterName];
      if (!filterFn) {
        throw "Unknown filter: '" + filterName + "'";
      }
      return filterFn.apply(scope, [val].concat(filterArgs));
    };
    if (Array.isArray(filters)) {
      result = val;
      for (i = 0, len = filters.length; i < len; i++) {
        f = filters[i];
        result = applyFilter(f, result);
      }
      return result;
    } else {
      return applyFilter(filters, val);
    }
  };

  evalJs = function(node, scope) {
    return eval(node.$js);
  };

  evalMap = function(node, scope) {
    var array, childScope, result, value, varName;
    array = evalExpression(node.$map, scope);
    varName = node.$as;
    value = nodeValue(node, '$body');
    result = [];
    childScope = makeChildScope(scope);
    array.forEach(function(item) {
      childScope[varName] = item;
      return result.push(evalNode(value, childScope));
    });
    return result;
  };

  nodeValue = function(node, valueAttr) {
    var key, value, valueObject;
    valueObject = node[valueAttr || '$value'];
    if (typeof valueObject !== 'undefined') {
      return valueObject;
    } else {
      valueObject = {};
      for (key in node) {
        value = node[key];
        if (!key.match(/^\$/)) {
          valueObject[key] = value;
        }
      }
      return valueObject;
    }
  };

  DIRECTIVES = {
    $if: evalIf,
    $switch: evalSwitch,
    $let: evalLet,
    $filter: evalFilter,
    $map: evalMap,
    $js: evalJs
  };

  parsePath = function(p) {
    return p.split('.').map(function(e) {
      return e.trim();
    });
  };

  getIn = function(obj, path) {
    var result;
    result = obj;
    path.forEach(function(x) {
      var getFirst;
      if (!(result === null || result === void 0)) {
        getFirst = false;
        if (x[x.length - 1] === '~') {
          x = x.substr(0, x.length - 1);
          getFirst = true;
        }
        result = result[x];
        if (getFirst && Array.isArray(result)) {
          return result = result[1];
        }
      }
    });
    return result;
  };

  evalExpression = function(expr, scope) {
    var args, e, filter, filterFn, filterRegexp, filters, i, len, name, pathRegexp, result;
    if (typeof scope === 'undefined') {
      throw "evalExpression() called with undefined scope. Expression is: " + expr;
    }
    pathRegexp = /"(?:[^"\\]|\\.)*"|([a-zA-Z_0-9~][a-zA-Z_0-9.~]+[a-zA-Z_0-9~])/g;
    filterRegexp = /(\s*\|\s*[a-zA-Z0-9_]+(\([^)]+\))?)*\s*$/;
    filters = null;
    e = expr.replace(filterRegexp, function(f_str) {
      filters = f_str.split(/\s*\|\s*/).map(function(f) {
        var args;
        f = f.trim();
        if (f.indexOf("(") > 0) {
          args = f.match(/\(([^)]+)\)$/)[1].split(",").map(JSON.parse);
          f = f.substr(0, f.indexOf("("));
          return [f, args];
        } else {
          return f;
        }
      });
      filters.shift();
      return "";
    });
    e = e.replace(pathRegexp, function(fullMatch, pathStr) {
      var path;
      if (pathStr) {
        path = parsePath(pathStr);
        return "getIn(scope, " + (JSON.stringify(path)) + ")";
      } else {
        return fullMatch;
      }
    });
    result = eval(e);
    for (i = 0, len = filters.length; i < len; i++) {
      filter = filters[i];
      if (Array.isArray(filter)) {
        name = filter.shift();
        args = filter;
      } else {
        name = filter;
        args = [];
      }
      filterFn = HELPERS[name];
      if (!filterFn) {
        throw "Unknown filter: '" + name + "'";
      }
      result = filterFn.apply(scope, [result].concat(args));
    }
    return result;
  };

  isDirective = function(node) {
    var key, value;
    for (key in node) {
      value = node[key];
      if (key.match(/^\$/)) {
        return true;
      }
    }
    return false;
  };

  evalDirective = function(node, scope) {
    var directiveFn, directiveName, keys, knownDirectives, nodeKeys;
    knownDirectives = Object.keys(DIRECTIVES);
    nodeKeys = Object.keys(node);
    keys = intersectArrays(nodeKeys, knownDirectives);
    if (keys.length === 0) {
      throw "Could not find known directive among " + (nodeKeys.join(', ')) + "; Known directives are: " + (knownDirectives.join(', '));
    } else if (keys.length > 1) {
      throw "Ambigous node with multiple directives found: " + (keys.join(', '));
    }
    directiveName = keys[0];
    directiveFn = DIRECTIVES[directiveName];
    return directiveFn(node, scope);
  };

  evalObject = function(node, scope) {
    var key, result, value;
    if (isDirective(node)) {
      return evalDirective(node, scope);
    } else {
      result = {};
      for (key in node) {
        value = node[key];
        result[key] = evalNode(value, scope);
      }
      return result;
    }
  };

  evalString = function(node, scope) {
    var expressionStartRegexp;
    expressionStartRegexp = /^\s*\$\s+/;
    if (node.match(expressionStartRegexp)) {
      return evalExpression(node.replace(expressionStartRegexp, ''), scope);
    } else {
      return node;
    }
  };

  evalNode = function(node, scope) {
    var nodeType;
    if (typeof scope === 'undefined') {
      throw "evalNode() called with undefined scope. Node is: " + (JSON.stringify(node));
    }
    nodeType = typeof node;
    if (nodeType === 'object' && node !== null) {
      if (Array.isArray(node)) {
        return node.map(function(element) {
          return evalNode(element, scope);
        });
      } else {
        return evalObject(node, scope);
      }
    } else {
      if (nodeType === 'string') {
        return evalString(node, scope);
      } else if (nodeType === 'undefined') {
        return null;
      } else {
        return node;
      }
    }
  };

  transform = function(scope, template) {
    return evalNode(template, scope);
  };

  module.exports = {
    transform: transform
  };

}).call(this);
